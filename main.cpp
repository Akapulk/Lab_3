#include <iostream>
#include "Arithmetic.h"
#include "Geometric.h"

using namespace std;

int main()
{
	setlocale(LC_ALL, "");

	bool flag = true;
	int menu;
	int count; 
	Arithmetic arith; //объект ар. прогрессии
	Geometric geom; //объект геом. прогессии
	Base *ptr; //указатель базового класса

	while (flag)
	{
		//меню
		system("cls");//очистка командной строки
		cout << "1) Арифметическая прогрессия" << endl;
		cout << "2) Геометрическая прогрессия" << endl;
		cout << "0) Выход" << endl;
		cout << "Выберите команду: ";
		cin >> menu;

		switch (menu)
		{
		case 1:
			ptr = &arith; //говорим, что указатель равен адресу объекта-потомка, такое возможно, потому что класс Arithmetic потомок класса Base
			system("cls");//очистка командной строки
			cout << "1) Вывод суммы n-элементов" << endl;
			cout << "2) Изменение данных" << endl;
			cout << "0) Выход в основное меню" << endl;
			cout << "Выберите команду: ";
			cin >> menu;
			if (cin.fail()) { //проверка на некорректный ввод
				menu = -1; //устанавливаем значение figure равным -1
				cin.clear(); //очищает флаг ошибки cin (так что будущие операции ввода-вывода будут работать правильно)

				/*КОД НИЖЕ: переходит к следующей новой строке(чтобы игнорировать что - либо еще в той же строке,
				чтобы оно не вызывало другого сбоя анализа). Он будет пропускать только до 10000 символов,
				поэтому код предполагает, что пользователь не будет вводить очень длинную недопустимую строку. */
				cin.ignore(10000, '\n');
			}
			/*у нас указатель имеет тип базового класса, то через него можно
			получить доступ к виртуальным функциям классов наследников */
			switch (menu)
			{
			case 1:
				cout << endl << "Введите количество элементов: ";
				cin >> count; //вводим количество первых элементов, сумму которых хотим посчитать
				/*так как функция sum виртуальная, то мы к ней можем обратиться с помощью указателя базового класса, заранне сказав,
				что указатель равен адресу объекта-наследника*/
				ptr->sum(count);
				system("pause");
				break;
			case 2:
				/*так как функция change не виртуальная, то мы не можем получить к ней доступ через указатель базового класса,
				можно получить доступ только через объект этого класса*/
				arith.change();
				break;
			}
			break;
		case 2:
			ptr = &geom; //говорим, что указатель равен адресу объекта-потомка, такое возможно, потому что класс Geometric потомок класса Base
			system("cls");//очистка командной строки
			cout << "1) Вывод суммы n-элементов" << endl;
			cout << "2) Изменение данных" << endl;
			cout << "0) Выход в основное меню" << endl;
			cout << "Выберите команду: ";
			cin >> menu;

			/*у нас указатель имеет тип базового класса, то через него можно
			получить доступ к виртуальным функциям классов наследников */
			switch (menu)
			{
			case 1:
				/*так как функция sum виртуальная, то мы к ней можем обратиться с помощью указателя базового класса, заранне сказав,
				что указатель равен адресу объекта-наследника*/
				cout << endl << "Введите количество элементов: ";
				cin >> count; //вводим количество первых элементов, сумму которых хотим посчитать
				ptr->sum(count); 
				system("pause");
				break;
			case 2:
				/*так как функция change не виртуальная, то мы не можем получить к ней доступ через указатель базового класса,
				можно получить доступ только через объект этого класса*/
				geom.change();
				break;
			}
			break;
		case 0: flag = false; break;
		default: cout << "Некорректный ввод" << endl; system("pause");
		}
	}
	return 0;
}